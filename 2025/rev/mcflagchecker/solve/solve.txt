First, reset the datapack using /reload. Input the flag as ASCII decimal ints in registers 0-39 inclusive. I have written a solve script/solve datapack function that automates this but you can do it manually with commands. The datapack will first XOR the flag with a sequence generated by an LCG. Then it will take 6 ^ char % 251 for each char in the modified flag. Then it will perform a matrix multiplication mod 251 with the 40x40 jukebox storage matrix and the transformed flag to get a new 40 values for registers 0-39. Then it will check these values and if they all match a certain output, you will get the diamonds. To find the input flag, invert the matrix (mod 251), take a discrete log with respect to 6 mod 251 (this can be precomputed/brute forced), and XOR with the LCG sequence.

By the way, the datapack was compiled using CBscript, a language made my Sethbling (I didn't write the datapack by hand). It currently works for 1.20.4. The reason the datapack was so large is because a lot of loops including the matrix multiplication were completely unrolled as I couldnâ€™t find a great way to dynamically set/get/operate on scoreboard objectives based on a value (such as an iterator/counter) stored in the scoreboard

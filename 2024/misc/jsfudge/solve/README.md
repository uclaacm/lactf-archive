# JsFudge

JsFudge this, JsFudge that, why don't you JsFudge the flag.

Author Writeup by r2dev2

## Intro

In this challenge, we have arbritrary `eval` RCE access into a nodejs function on the condition that we can only use the [jsfuck characters](https://jsfuck.com/). Also, the prototype for `.toString()` for `Array` has been overwritten.

The way JsFuck works is that it uses js quirks to generate strings that eventually result in running `Function("return eval")()("some code generated by adding strings")`. To construct these strings, JsFuck will use array operations to create strings like `"undefined"` and then numerically index into them for specific characters like `e`. To construct numbers, jsfuck uses `+[]` for `0`, `+!+[]` for `1`, and more. It combines them in interesting ways using `[1, 2, 3]` which can in some cases be interpreted as `123` due to the way `Array.toString()` works. However, since the built-in `toString()` does not work, we must improvise.

## Solution

### Plain JS Payload

One thing to notice about the way jsfuck works is that we cannot access the global scope since JsFuck uses the `eval` in the scope of the `Function` environment.

Ideally, we would want something like:

```js
require('fs').readFileSync('flag.txt')
```

However, `require` is not found. We must intead get `require` through `process.mainModule.require`. After that, our plain js payload is:

```js
process.mainModule.require("fs").readFileSync("flag.txt")
```

### Encoding as JsFuck

If you try to straight-up plug in the payload into https://jsfuck.com or another compiler online, you may notice that we get weird errors like `nyaundefined is not a function`. This is because the default jsfuck assumes that `[].toString()` is empty and other things about default `.toString()`. To get around this, we will write our own version of `jsfuck.js` which uses operations that work even if the prototype of `Array` is polluted.

#### Getting Numbers

Instead of getting numbers through casting arrays as numbers, we can combine booleans into numbers.

```js
> ![]+![]
0
> ![]+!![]
1
```

We override the section of `jsfuck.js` dealing with numbers to use our new numbering scheme.

In addition to this, we must also overrite the way jsfuck deals with multi-digit numbers. To optimize for space, JsFuck encodes each digit as a number and concatenates them together. This will not work with our new array prototype, so we remove that part and just keep adding `+!![]` to get numbers. While this results in a massive payload, it will work.


#### Fixing Letters

Now, we will fix the letters that are misspelled. I wrote a tiny `encode.js` which imports from a `jsfuck.js` and encodes a small payload to quickly test this out. To fix letters, I either corrected the index (as the `^w^` messes with indexes) or I converted it to use `String.fromCharCode`. I finally got a payload that works.

#### Submitting Payload

Locally, I was able to submit the payload through piping into `nc`. However, it didn't seem to work for the dockerized version, so I wrote a pwntools script to get me the flag.

```
[rbadhe@ar2ch solve]$ python3 solve.py
[+] Opening connection to 0.0.0.0 on port 5000: Done
b'flag{d0_y0u_f331_pr0ud}\n'
[*] Closed connection to 0.0.0.0 port 5000
```
